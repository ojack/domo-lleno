{"version":3,"file":"static/webpack/static/development/pages/_app.js.b6d5513e70b62e677767.hot-update.js","sources":["webpack:///./components/3d/dome.js"],"sourcesContent":["// explode geometry: https://stackoverflow.com/questions/46412425/separate-each-face-of-icosahedron-geometry-by-some-empty-space-around-it-using-t\n// Our Javascript will go here.\n//const shader = require('./js/solid.shader.js')\n//global.THREE = require('three')\n\nimport * as THREE from 'three'\nimport EffectComp from 'three-effectcomposer'\nconst EffectComposer = EffectComp(THREE)\nimport ExplodeModifier from './utils/ExplodeModifier.js'\n//const createFXAA = require('three-shader-fxaa');\n\nimport createScene from './createScene.js'\nimport createLoop from 'raf-loop'\nimport colorShaders from './shaders/color.shader.js'\n\n\n\nexport default containerElement => {\n  const {\n    renderer,\n    camera,\n    scene,\n    renderScene\n  } = createScene(THREE)\n\n  containerElement.appendChild(renderer.domElement)\n  // Create a new offscreen framebuffer\n  const target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);\n  target.texture.stencil = false;\n  target.texture.minFilter = THREE.LinearFilter;\n  target.texture.magFilter = THREE.LinearFilter;\n  target.texture.format = THREE.RGBFormat;\n  target.texture.generateMipmaps = false;\n\n  // Create a new composer for post-processing\n  const composer = new EffectComposer(renderer, target);\n\n  // Copy scene to framebuffer\n  composer.addPass(new EffectComposer.RenderPass(scene, camera))\n\n//composer.addPass(new EffectComposer.ShaderPass(createFXAA()))\n\n  // Add the postprocessing shader\n  console.log('color shaders', colorShaders)\n  const color = new EffectComposer.ShaderPass({\n    vertexShader: colorShaders.vertex,\n    fragmentShader: colorShaders.fragment,\n    uniforms: {\n      tDiffuse: { type: 't', value: new THREE.Texture() },\n      tLookup: { type: 't', value: new THREE.Texture() },\n      time: { // float initialized to 0\n        type: \"f\",\n        value: 0.0\n      }\n    }\n  });\n  composer.addPass(color);\n\n  // Setup our lookup table for the color transform shader\n  const tLookup = new THREE.TextureLoader().load('/static/images/colors.png');\n  tLookup.generateMipmaps = false;\n  tLookup.minFilter = THREE.LinearFilter;\n  color.uniforms.tLookup.value = tLookup;\n\n  // Last pass should be rendered to screen!\n  composer.passes[composer.passes.length - 1].renderToScreen = true\n\n  var start = Date.now()\n  // Render loop\n  var explodeAmount = 1.0\n  var explodeDirection = -1\n\n  function render () {\n\n    composer.passes.forEach(pass => {\n      if(pass.uniforms && pass.uniforms.time) {\n        pass.uniforms.time.value = .0001 * ( Date.now() - start )\n      }\n    })\n\n    composer.render()\n  }\n\n  var animateFunction = () => {}\n\n  //animateIn(5)\n\nfunction triggerAnimation(duration, direction){\n  animateFunction = animate(duration, direction)\n}\n\nfunction animate(duration, direction) {\n  var elapsedTime = 0\n  var animationProgress = 0\n  return (dt) => {\n\n    elapsedTime += dt/1000\n    animationProgress = Math.max(Math.min(elapsedTime / (duration), 1.0), 0.0)\n      //console.log('time', elapsedTime, 'animProg', animationProgress)\n    if(direction === 'closed') return 1.0 - animationProgress\n    return animationProgress\n  }\n}\n  // function animateIn(duration) {\n  //   var elapsedTime = 0\n  //   var animationProgress = 0\n  //   return (dt) => {\n  //\n  //     elapsedTime += dt/1000\n  //     animationProgress = Math.max(Math.min(elapsedTime / (duration), 1.0), 0.0)\n  //       //console.log('time', elapsedTime, 'animProg', animationProgress)\n  //     return 1.0 - animationProgress\n  //   }\n  // }\n  //\n  // function animateOut(duration) {\n  //   var elapsedTime = 0\n  //   var animationProgress = 0\n  //   return (dt) => {\n  //\n  //     elapsedTime += dt/1000\n  //     animationProgress = Math.max(Math.min(elapsedTime / (duration), 2.0), 0.0)\n  //       //console.log('time', elapsedTime, 'animProg', animationProgress)\n  //     return animationProgress\n  //   }\n  // }\n\n  createLoop((dt) => {\n  //  console.log('anim function', animateFunction(dt))\n  //  console.log('rendering')\n    var progress = animateFunction(dt)\n    //console.log('progress', progress)\n    composer.passes.forEach(pass => {\n      if(pass.uniforms && pass.uniforms.time) {\n        pass.uniforms.time.value = .0001 * ( Date.now() - start )\n      }\n    })\n\n    renderScene(progress*3.0)\n    composer.render()\n  }).start()\n\n  return {\n    render, triggerAnimation\n  }\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAHA;AAHA;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AADA;AAGA;;;;A","sourceRoot":""}